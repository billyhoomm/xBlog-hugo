---
title: 远程tail -f自动退出方法
subtitle: 
date: 2019-04-04
tags: ["运维", "golang", "shell"]
draft: true
---

问题的起因是最近在写一个单点日志查看工具，服务端可以通过ssh协议查看被控端服务器上的日志。可以方便开发人员在测试环境调试多个子系统。

能够实时远程查看文件新增内容，而不用部署插件到被控端。我第一个想到的就是在ssh中使用tail。

<!--more-->

有了最初的想法，我写了如下的函数，语言我用的是golang

```golang
func TailLog(host, password, logFileDir string) {
    var (
        client     *ssh.Client              // ssh客户端
        session    *ssh.Session             // ssh会话连接
        LogChan    = make(chan []byte, 300) // log输出channel
        cmdReader  io.Reader                // ssh会话Stdout
        logScanner *bufio.Scanner           // 缓冲读取log
        err        error
    )

    // 从缓存池中获取预定的ssh-client连接对象，此时还未真正连接到被控端开始会话
    client, err = getOrCreateClient(host, password)
    if err != nil {
        return nil, nil, err
    }

    // 会话连接
    session, err = client.NewSession()
    if err != nil {
        return nil, nil, err
    }
    defer session.close()

    cmdReader, err = session.StdoutPipe()
    if err != nil {
        return nil, nil, err
    }
    logScanner = bufio.NewScanner(cmdReader)

    // 后台将读取的log放入logChan
    go func(logScan *bufio.Scanner, logChan chan<- []byte) {
        for logScan.Scan() {
            // 按行发送，行尾附加回车换行符
            LogChan <- []byte(logScan.Text())
        }
    }(logScanner, LogChan)

    // 极易被注入式攻击 必须添加参数校验
    if err = session.Start(fmt.Sprintf("tail -200f %s", logFileDir)); err != nil {
        return nil, nil, err
    }

    // 开始打印log内容
    for log := range logChan {
        fmt.println(string(log))
    }
}
```

总的来说就是远程执行"tail -200f filename"命令，获取输出信息。但该函数执行完成后，tail这条命令依旧会在远端主机执行着，ps工具查看依旧在执行中。如果多次执行，就会这样：

![](https://images.moonlightming.top/images/20190404180938.png)

运行一段时间后机器内会积累大量该类进程，肯定是不优雅，而且会占用主机资源的。那么我希望在断开ssh连接后能够终止这类